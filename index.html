<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>French Pronunciation Checker</title>
  <style>
    /* CSS G·ªêC - KH√îNG S·ª¨A GIAO DI·ªÜN */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { height: 100%; width: 100%; }
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: flex; flex-direction: column; overflow: hidden; }
    .app-container { width: 100%; height: 100%; display: flex; flex-direction: column; padding: 24px; overflow: auto; }
    .header { text-align: center; margin-bottom: 24px; }
    .header h1 { color: #ffffff; font-size: 32px; font-weight: 700; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2); }
    .api-status { background: rgba(255, 255, 255, 0.15); color: white; padding: 8px 16px; border-radius: 8px; margin-top: 8px; font-size: 14px; display: inline-block; }
    .api-status.active { background: rgba(72, 187, 120, 0.3); }
    .main-content { flex: 1; display: flex; flex-direction: column; max-width: 800px; width: 100%; margin: 0 auto; min-height: 0; }
    
    /* KHUNG HI·ªÇN TH·ªä CH·ªÆ - QUAN TR·ªåNG CHO HI·ªÜU ·ª®NG CU·ªòN */
    .text-display-wrapper { flex: 1; background: #ffffff; border-radius: 16px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15); overflow: hidden; margin-bottom: 20px; position: relative; min-height: 0; }
    .text-display { height: 100%; overflow: hidden; position: relative; padding: 32px; display: flex; align-items: flex-end; } /* Flex-end ƒë·ªÉ ch·ªØ b·∫Øt ƒë·∫ßu t·ª´ d∆∞·ªõi */
    
    .text-content { width: 100%; padding: 0; transform: translateY(100%); transition: none; }
    
    /* Animation cu·ªôn l√™n trong 60s */
    .text-content.scrolling { transition: transform 60s linear; transform: translateY(-100%); }
    
    .word { display: inline; font-size: 24px; line-height: 1.8; padding: 2px 4px; border-radius: 4px; transition: background-color 0.2s ease, color 0.2s ease; color: #2d3748; }
    
    /* M√ÄU XANH KHI ƒê·ªåC ƒê√öNG */
    .word.correct { background-color: #48bb78; color: #ffffff; text-shadow: 1px 1px 2px rgba(0,0,0,0.2); }
    
    /* Con tr·ªè g·ª£i √Ω (n·∫øu c·∫ßn) */
    .word.suggest { border-bottom: 3px solid #ed8936; }

    .controls { display: flex; gap: 16px; align-items: center; justify-content: center; background: rgba(255, 255, 255, 0.95); padding: 20px; border-radius: 16px; box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1); margin-bottom: 16px; }
    .btn { padding: 14px 28px; font-size: 16px; font-weight: 600; border: none; border-radius: 12px; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); min-width: 120px; }
    .btn-start { background: #48bb78; color: #ffffff; }
    .btn-start:hover:not(:disabled) { background: #38a169; transform: translateY(-2px); box-shadow: 0 6px 16px rgba(72, 187, 120, 0.4); }
    .btn-reset { background: #ed8936; color: #ffffff; }
    .btn-reset:hover:not(:disabled) { background: #dd6b20; transform: translateY(-2px); box-shadow: 0 6px 16px rgba(237, 137, 54, 0.4); }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .timer { display: flex; align-items: center; gap: 12px; padding: 12px 24px; background: #edf2f7; border-radius: 12px; font-size: 20px; font-weight: 700; color: #2d3748; min-width: 140px; justify-content: center; }
    .stats { background: rgba(255, 255, 255, 0.95); padding: 20px; border-radius: 16px; box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1); display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap; gap: 16px; }
    .stat-item { text-align: center; }
    .stat-label { font-size: 14px; color: #718096; margin-bottom: 4px; font-weight: 500; }
    .stat-value { font-size: 28px; font-weight: 700; color: #2d3748; }
    .stat-value.correct { color: #48bb78; }
    .notification { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); padding: 16px 24px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); z-index: 1000; text-align: center; max-width: 90%; font-weight: 600; color: white; animation: slideDown 0.3s ease; }
    @keyframes slideDown { from { transform: translate(-50%, -100%); opacity: 0; } to { transform: translateX(-50%); opacity: 1; } }
    .recording-indicator { position: fixed; bottom: 20px; right: 20px; background: rgba(0, 0, 0, 0.8); color: white; padding: 12px 20px; border-radius: 12px; display: none; align-items: center; gap: 10px; font-size: 14px; z-index: 1001; }
    .recording-indicator.active { display: flex; }
    .pulse { width: 10px; height: 10px; background: #f56565; border-radius: 50%; animation: pulse 1s infinite; }
    @keyframes pulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.5; transform: scale(1.3); } }
    @media (max-width: 768px) { .app-container { padding: 16px; } .header h1 { font-size: 24px; } .word { font-size: 18px; } .controls { flex-direction: column; gap: 12px; } .btn { width: 100%; min-width: auto; } .timer { width: 100%; } }
  </style>
</head>
<body>
  <div class="app-container">
    <header class="header">
      <h1>üá´üá∑ French Pronunciation Checker</h1>
      <div class="api-status" id="apiStatus">ü§ñ OpenAI Whisper Ready</div>
    </header>
    <main class="main-content">
      <div class="text-display-wrapper">
        <div class="text-display">
          <div class="text-content" id="textContent"></div>
        </div>
      </div>
      <div class="controls">
        <button class="btn btn-start" id="startBtn">D√©marrer</button>
        <div class="timer"><span>‚è±Ô∏è</span><span id="timerDisplay">1:00</span></div>
        <button class="btn btn-reset" id="resetBtn">Nouveau texte</button>
      </div>
      <div class="stats">
        <div class="stat-item"><div class="stat-label">Pr√©cision</div><div class="stat-value" id="accuracyDisplay">0%</div></div>
        <div class="stat-item"><div class="stat-label">Correct</div><div class="stat-value correct" id="correctDisplay">0</div></div>
        <div class="stat-item"><div class="stat-label">Total</div><div class="stat-value" id="totalDisplay">0</div></div>
      </div>
    </main>
  </div>
  <div class="recording-indicator" id="recordingIndicator"><div class="pulse"></div><span>ƒêang nghe (Mic li√™n t·ª•c)...</span></div>

  <script>
    const frenchTexts = [
      {
        level: "A1",
        text: "Bonjour je m'appelle Marie. J'habite √† Paris. J'aime beaucoup le chocolat et les croissants. Tous les matins je vais √† la boulangerie. Je bois du caf√© avec mes amis. Nous parlons de notre journ√©e. Le weekend je visite des mus√©es. J'adore l'art et la culture fran√ßaise."
      },
      {
        level: "A2",
        text: "Hier j'ai visit√© le Louvre avec ma famille. C'√©tait magnifique. Nous avons vu la Joconde et beaucoup d'autres tableaux c√©l√®bres. Apr√®s le mus√©e nous sommes all√©s manger dans un restaurant traditionnel. J'ai command√© du boeuf bourguignon. C'√©tait excellent. Mon fr√®re a pris des escargots pour la premi√®re fois."
      },
      {
        level: "B1",
        text: "Chaque matin Julien se r√©veille avant le lever du soleil. Il prend quelques minutes pour regarder le ciel et respirer profond√©ment. Pour lui le temps est pr√©cieux et chaque journ√©e m√©rite d'√™tre v√©cue avec attention. Autrefois Julien passait ses journ√©es √† courir sans r√©fl√©chir. Il travaillait beaucoup et parlait peu avec les autres."
      },
      {
        level: "B2",
        text: "La r√©volution num√©rique a profond√©ment transform√© nos modes de vie et nos interactions sociales. Si elle offre des opportunit√©s sans pr√©c√©dent en termes de communication et d'acc√®s √† l'information elle soul√®ve √©galement des questions importantes concernant la protection de la vie priv√©e et la d√©pendance technologique."
      },
      {
        level: "C1",
        text: "L'anthropoc√®ne cette nouvelle √®re g√©ologique marqu√©e par l'impact pr√©pond√©rant des activit√©s humaines sur les √©cosyst√®mes terrestres constitue un d√©fi existentiel pour notre civilisation. Les scientifiques s'accordent sur l'urgence d'une transformation radicale de nos mod√®les √©conomiques et soci√©taux."
      }
    ];

    let currentText = [];
    let isRunning = false;
    let timeRemaining = 60;
    let timerInterval = null;
    let stats = { correct: 0, total: 0 };
    
    // --- C·∫§U H√åNH X·ª¨ L√ù ---
    let lastSuccessIndex = -1; // Neo ng·ªØ c·∫£nh
    let mediaRecorder = null;
    let audioChunks = [];
    let sendDataInterval = null;

    const textContent = document.getElementById('textContent');
    const startBtn = document.getElementById('startBtn');
    const resetBtn = document.getElementById('resetBtn');
    const timerDisplay = document.getElementById('timerDisplay');
    const accuracyDisplay = document.getElementById('accuracyDisplay');
    const correctDisplay = document.getElementById('correctDisplay');
    const totalDisplay = document.getElementById('totalDisplay');
    const recordingIndicator = document.getElementById('recordingIndicator');
    const apiStatus = document.getElementById('apiStatus');

    function showNotification(message, isError = false) {
      const notification = document.createElement('div');
      notification.className = 'notification';
      notification.style.background = isError ? '#f56565' : '#48bb78';
      notification.textContent = message;
      document.body.appendChild(notification);
      setTimeout(() => {
        notification.style.animation = 'slideDown 0.3s ease reverse';
        setTimeout(() => notification.remove(), 300);
      }, 3000);
    }

    async function transcribeAudio(audioBlob) {
      try {
        const formData = new FormData();
        formData.append('audio', audioBlob, 'audio.webm');
        const response = await fetch('/api/transcribe', { method: 'POST', body: formData });
        if (!response.ok) return null;
        const result = await response.json();
        if (result.error) return null;
        
        if (result.text && result.text.trim().length > 0) {
            console.log('üó£Ô∏è User said:', result.text);
            if (isRunning) checkPronunciationContextAware(result.text);
        }
        return result.text;
      } catch (error) {
        console.error('‚ùå Transcription error:', error);
        return null;
      }
    }

    async function startRecording() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
          audio: { channelCount: 1, sampleRate: 48000, echoCancellation: true, noiseSuppression: true, autoGainControl: true } 
        });

        mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm;codecs=opus', audioBitsPerSecond: 128000 });
        audioChunks = [];
        
        // Thu th·∫≠p data
        mediaRecorder.ondataavailable = (event) => { if (event.data.size > 0) audioChunks.push(event.data); };
        
        // Start recorder continuous
        mediaRecorder.start(1000); 
        recordingIndicator.classList.add('active');

        // G·ª≠i data m·ªói 2 gi√¢y
        sendDataInterval = setInterval(() => {
            if (!isRunning || mediaRecorder.state !== 'recording') return;
            if (audioChunks.length > 0) {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                audioChunks = []; // Reset buffer
                if (audioBlob.size > 3000) transcribeAudio(audioBlob);
            }
        }, 2000);

      } catch (error) {
        console.error('‚ùå Recording error:', error);
        showNotification('‚ùå Erreur microphone', true);
        stopExercise();
      }
    }

    function normalizeText(text) {
      if (!text) return '';
      return text.toLowerCase()
        .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-z0-9\s]/g, '')
        .replace(/\s+/g, ' ')
        .trim();
    }

    function toPhonetic(word) {
      if (!word) return '';
      let p = word.toLowerCase();
      p = p.replace(/[tdspxz]$/, '');
      p = p.replace(/ent$/, 'e').replace(/er$/, 'e').replace(/ez$/, 'e');
      p = p.replace(/(.)\1+/g, '$1');
      return p;
    }

    function isWordMarked(index) {
        const el = document.getElementById(`word-${index}`);
        return el && (el.classList.contains('correct'));
    }

    function markWordCorrect(index) {
        const el = document.getElementById(`word-${index}`);
        if (el && !el.classList.contains('correct')) {
            el.classList.add('correct'); // CLASS N√ÄY S·∫º L√ÄM T·ª™ ƒê√ì XANH L√äN
            stats.correct++;
            updateStats();
        }
    }

    function checkPronunciationContextAware(spokenText) {
      if (!isRunning) return;
      
      const spokenWords = normalizeText(spokenText).split(/\s+/).filter(w => w.length > 0);
      const matchedIndicesInThisBatch = new Set();

      spokenWords.forEach((spokenWord) => {
        let bestCandidate = { index: -1, score: -1 };

        for (let i = 0; i < currentText.length; i++) {
          if (isWordMarked(i)) continue;
          if (matchedIndicesInThisBatch.has(i)) continue;

          const expectedWord = normalizeText(currentText[i]);
          let similarity = calculateSimilarity(spokenWord, expectedWord);
          
          if (similarity >= 0.75) {
            const anchor = lastSuccessIndex === -1 ? 0 : lastSuccessIndex;
            const distance = Math.abs(i - anchor);
            
            // Logic ∆∞u ti√™n t·ª´ g·∫ßn "neo" (Context Aware)
            let bonus = 0;
            if (i === lastSuccessIndex + 1) bonus = 0.2; 
            else if (i > lastSuccessIndex && i < lastSuccessIndex + 5) bonus = 0.1;
            const penalty = distance * 0.005; 

            const finalScore = similarity + bonus - penalty;

            if (finalScore > bestCandidate.score) {
              bestCandidate = { index: i, score: finalScore };
            }
          }
        }

        if (bestCandidate.index !== -1) {
          markWordCorrect(bestCandidate.index);
          matchedIndicesInThisBatch.add(bestCandidate.index);
          lastSuccessIndex = bestCandidate.index; // C·∫≠p nh·∫≠t neo
        }
      });
      
      // Update suggestion underline
      document.querySelectorAll('.word').forEach(w => w.classList.remove('suggest'));
      for (let i = 0; i < currentText.length; i++) {
        if (!isWordMarked(i)) {
          document.getElementById(`word-${i}`).classList.add('suggest');
          break;
        }
      }

      if (stats.correct >= currentText.length) stopExercise();
    }

    function calculateSimilarity(w1, w2) {
      if (!w1 || !w2) return 0;
      if (w1 === w2) return 1.0;
      const p1 = toPhonetic(w1);
      const p2 = toPhonetic(w2);
      if (p1 === p2 && p1.length > 0) return 0.95;
      const dist = levenshteinDistance(w1, w2);
      const len = Math.max(w1.length, w2.length);
      return (len - dist) / len;
    }

    function levenshteinDistance(s1, s2) {
      const m = [];
      for (let i = 0; i <= s2.length; i++) m[i] = [i];
      for (let j = 0; j <= s1.length; j++) m[0][j] = j;
      for (let i = 1; i <= s2.length; i++) {
        for (let j = 1; j <= s1.length; j++) {
          m[i][j] = s2[i-1] === s1[j-1] ? m[i-1][j-1] : Math.min(m[i-1][j-1] + 1, m[i][j-1] + 1, m[i-1][j] + 1);
        }
      }
      return m[s2.length][s1.length];
    }

    function loadRandomText() {
      const text = frenchTexts[Math.floor(Math.random() * frenchTexts.length)];
      currentText = text.text.split(/\s+/);
      textContent.innerHTML = '';
      currentText.forEach((word, i) => {
        const span = document.createElement('span');
        span.className = 'word';
        span.id = `word-${i}`;
        span.textContent = word + ' ';
        textContent.appendChild(span);
      });
      lastSuccessIndex = -1;
      textContent.classList.remove('scrolling'); // Reset tr·∫°ng th√°i cu·ªôn
      void textContent.offsetHeight; // Force reflow
    }

    async function startExercise() {
      if (isRunning) return;
      isRunning = true;
      timeRemaining = 60;
      stats = { correct: 0, total: 0 };
      lastSuccessIndex = -1;

      document.querySelectorAll('.word').forEach(w => {
        w.classList.remove('correct', 'suggest');
      });
      
      updateStats();
      startBtn.disabled = true;
      
      // K√çCH HO·∫†T HI·ªÜU ·ª®NG CU·ªòN
      textContent.classList.add('scrolling');
      
      apiStatus.classList.add('active');
      apiStatus.textContent = 'üü¢ ƒêang nghe...';
      
      startTimer();
      await startRecording();
      showNotification('üé§ B·∫Øt ƒë·∫ßu! Ch·ªØ s·∫Ω t·ª± ch·∫°y...');
    }

    function startTimer() {
      const startTime = Date.now();
      timerInterval = setInterval(() => {
        const remaining = Math.max(0, 60000 - (Date.now() - startTime));
        timeRemaining = Math.ceil(remaining / 1000);
        timerDisplay.textContent = `${Math.floor(timeRemaining / 60)}:${(timeRemaining % 60).toString().padStart(2, '0')}`;
        if (remaining <= 0) stopExercise();
      }, 100);
    }

    function stopExercise() {
      isRunning = false;
      clearInterval(timerInterval);
      clearInterval(sendDataInterval);
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
        mediaRecorder.stream.getTracks().forEach(track => track.stop());
      }
      recordingIndicator.classList.remove('active');
      startBtn.disabled = false;
      textContent.classList.remove('scrolling'); // D·ª´ng cu·ªôn
      apiStatus.classList.remove('active');
      apiStatus.textContent = 'ü§ñ OpenAI Whisper Ready';
      const acc = currentText.length > 0 ? Math.round((stats.correct / currentText.length) * 100) : 0;
      showNotification(`‚úÖ H·∫øt gi·ªù! K·∫øt qu·∫£: ${acc}%`);
    }

    function resetExercise() { stopExercise(); loadRandomText(); timerDisplay.textContent = '1:00'; accuracyDisplay.textContent = '0%'; correctDisplay.textContent = '0'; totalDisplay.textContent = '0'; }
    function updateStats() {
      const totalWords = currentText.length;
      const accuracy = totalWords > 0 ? Math.round((stats.correct / totalWords) * 100) : 0;
      accuracyDisplay.textContent = `${accuracy}%`;
      correctDisplay.textContent = stats.correct;
      totalDisplay.textContent = totalWords;
    }

    startBtn.addEventListener('click', startExercise);
    resetBtn.addEventListener('click', resetExercise);
    loadRandomText();
  </script>
</body>
</html>
